import os
import json
import uuid
import openai

import pprint
from scripts.weaviate_utils import WeaviateUtils
from scripts.fuseki_utils import FusekiUtils

# This class implements "get-problems" for EliozoClient
# This is an integrated function. 
class OpenaiFunctionAgent:
    openai_api_key = "NA"
    weaviate_url = "NA"
    weaviate_api_key = "NA"
    gpt_model = "gpt-4.1"

    function_specs = [
        {
            "type": "function",
            "function": {
                "name": "find_topics",
                "description": "Find problem topics that best match a user-provided query.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "user_query": { "type": "string", "description": "User prompt about desired math problems." }
                    },
                    "required": ["user_query"]
                }
            }
        },
        {
            "type": "function",
            "function": {
                "name": "query_fuseki",
                "description": "Submit a SPARQL query to Fuseki for problems on a topic.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "label": { "type": "string", "description": "Topic label to query." },
                        "grade": { "type": "integer", "description": "Grade if specified." },
                        "count": { "type": "integer", "description": "Number of problems to retrieve." },
                        "complexity": { "type": "string", "description": "Complexity filter." }
                    },
                    "required": ["label"]
                }
            }
        }
    ]

    SYSTEM_PROMPT = """
    You are a worksheet generator for math teachers. Analyze the worksheet request, 
    use the tools 'find_topics' and 'query_fuseki' to get at least the estimated_problem_count
    specified in the worksheet request. 
    Arrange them in a logical, teaching-friendly order and output as JSON. 
    Please write all mathematical expressions as LaTeX between $-signs for inline formulas
    or between $$-signs if they are wide formulas. Use proper JSON escaping - for example: $a \\cdot b$.
    JSON example (may be unrelated to the requested content):
    ```
    {
	"snippets": [
	  {
	    "type": "title",
		"value": "Dirihlē princips un kombinatorika 8. klasei"
	  },
	  {
	    "type": "section_title",
		"value": "Ievaduzdevumi"
	  },
	  {
		"type": "annotation",
		"value": "Divi iesildoši uzdevumi, lai atgādinātu matemātiskās loģikas pamatus un praktisko domāšanu."
	  },
	  {
		"type": "problem",
        "problemid" : "LV.AMO.2004.8.2"
		"value": "Mākslinieku grupa Arcane pasaulē vēlas sadalīt 25 portretus piecās izstādēs tā, ka katrā izstādē ir vismaz viens portrets. Vai tas vienmēr ir iespējams? Ja jā/nē, paskaidro, kāpēc."
	  },
	  {
		"type": "solution",
		"value": "Nav obligāti iespējams, ja portretus nedrīkst likt vienā izstādē: ja visi portreti tiek ielikti vienā izstādē, pārējās būs tukšas."
	  },
	 // Any more problems that belong to section "Ievaduzdevumi"
	  {
	  	"type": "section_title",
		"value": "Teorijas pārskats"
	  },
	  {
	    "type": "theorem",
		"value": "Dirihlē princips (pigeonhole principle): Ja starp n objektiem samet m kastēs un n > m, kādā kastē noteikti būs vismaz 2 objekti."
	  },
	// Any more theorems that belong to section "Teorijas pārskats"
	  {
		"type": "section_title",
		"value": "Uzdevumi"
	  },
	  {
		"type": "annotation",
		"value": "Uzdevumi ar pieaugošu grūtību, aptverot kombinatoriku, ģeometriju, skaitļu teoriju. Dažādi tipiski risināšanas uzdevumu piemēri."
	  }
	]
    }
    ``` 
    Please adapt about 2/3 of all problems from those returned by query_fuseki and about 1/3 should be newly generated.
    If snippet is of "type": "problem" and the problem text is derived from a Fuseki database problem,
    then it must have "problemid" returned by query_fuseki function. 
    If a problem is generated by you, then it should contain "problemid": "NEW". 
    """

    def __init__(self, openai_api_key, fuseki_url, fuseki_user, fuseki_password, weaviate_url, weaviate_api_key):
        self.weaviate_url = weaviate_url
        self.weaviate_api_key = weaviate_api_key
        self.openai_api_key = openai_api_key
        self.fuseki_url = fuseki_url
        self.fuseki_user = fuseki_user
        self.fuseki_password = fuseki_password


    def read_json(self, filename):
        with open(filename, 'r', encoding='utf-8') as f:
            return json.load(f)

    def write_json(self, filename, obj):
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(obj, f, indent=2, ensure_ascii=False)

    # ---- Local mock functions (Replace with real logic) ----
    def find_topics(self, user_query):
        #return ["PigeonholePrincipleBasic", "PigeonholePrincipleGeneralized", "PigeonholePrincipleGeometry"]
        return ["ArithmeticIdentities", "DivisibilityRulesLastDigits", "SequenceGaps"]

    def find_topics_weaviate(self, user_query):
        # HOW TO TEST: python eliozo_client.py get-problems --worksheet ../tests/get-problems/worksheet.json  --reference ../tests/get-problems/task.json
        print(f'CALLED find_topics({user_query})')
        # Replace this with your actual (encoder/transformer) logic
        # return ["PigeonholePrincipleBasic", "PigeonholePrincipleGeneralized", "PigeonholePrincipleGeometry"]
        weaviateUtils = WeaviateUtils(self.weaviate_url, 
                            self.weaviate_api_key, 
                            self.openai_api_key)

        print(f'get_classifiers: Getting classifier data from Weaviate')
        #(retvalue, data) = weaviateUtils.ingest_classifier_data(property, turtle)
        results = weaviateUtils.near_search("Classifier", user_query, 10)
        print(results)
        # TODO ar for ciklu iet cauri results un katram masīva elementam izvelk vērtību atslēgai label
        #  un piešķir tos jaunam sarakstam
        # Atgriezt nevis results, bet sarakstu, kurā ir tikai labels vērtības. 
        # Paraugs, kā tam būtu jāizskatās - # return ["PigeonholePrincipleBasic", "PigeonholePrincipleGeneralized", "PigeonholePrincipleGeometry"]
        return results
        #return (0, {}) 

    # TODO:
    # Šobrīd pēc dotā label atrod tikai uzdevumu problemid un tekstus
    # Daudzām darba lapām vajag atrisinājumus, un varētu SPARQL pamainīt, tā, lai līdz ar katru uzdevumu atrastu arī viņa atrisinājumu
    # Paraugi, kā to izdarīt ir qualification-project init py failā.
    # Atgriežamo uzdevumu sarakstā var pievienot jaunu atribūtu solution
    # TODO 2:
    # Šobrīd vaicājums ignorē grade (grade ne lielāku par to, kas ir uzdots, piemēram 8kl var rēķināt arī 7,6kl utt.)
    #  un count (fuseki vaicājumā tas būtu, piemēram, limit 10)
    def query_fuseki(self, label, grade=None, count=None, complexity=None):
        print(f'CALLED query_fuseki({label}, {grade}, {count}, {complexity})')
        res = []
        fuseki_utils = FusekiUtils(self.fuseki_url, self.fuseki_user, self.fuseki_password)
        myquery = """PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX eliozo: <http://www.dudajevagatve.lv/eliozo#>
SELECT DISTINCT ?problem ?problemid ?text ?grade
WHERE {{
    ?parent skos:prefLabel '{label}' .
    ?parent skos:narrower* ?subtopic .
    ?problem eliozo:topic ?subtopic ;
             eliozo:problemID ?problemid ;
             eliozo:problemTextHtml ?text ;
             eliozo:problemGrade ?grade .
}} ORDER BY ?grade"""
        myquery = myquery.format(label = label)
        print(f"Myquery = {myquery}")
        results = fuseki_utils.execute_query("abc", myquery)
        for item in results['results']['bindings']:
            res.append({
                "problemid": item['problemid']['value'],
                "topic": label,
                "text": item['text']['value'],
                # solution
                "grade": int(item['grade']['value'])
            })
        return res

    # ---- OpenAI tool/function definition ----


    def main(self, task_data, worksheet):
        openai.api_key = self.openai_api_key

        # Step 1: Read user query from file
        user_query = task_data["task"]["query"]

        merged_task = task_data.copy()

        # Function-calling workflow to assemble problems
        messages = [
            {"role": "system", "content": self.SYSTEM_PROMPT},
            {"role": "user", "content": f"Generate problems for worksheet: {json.dumps(merged_task['task'], ensure_ascii=False)}"}
        ]
        functions_map = {"find_topics": self.find_topics, "query_fuseki": self.query_fuseki}

        finished = False
        worksheet_json = None
        collected_problems = []
        topics_used = []
        max_iterations = 3  # Avoid infinite loops


        for _ in range(max_iterations):
            completion = openai.chat.completions.create(
                model=self.gpt_model,
                messages=messages,
                tools=self.function_specs,
                tool_choice="auto"
            )
            msg = completion.choices[0].message

            if msg.tool_calls:
                # For each tool_call, do the call and gather response
                tool_responses = []
                for tool_call in msg.tool_calls:
                    fn_name = tool_call.function.name
                    fn_args = json.loads(tool_call.function.arguments)
                    ret = functions_map[fn_name](**fn_args)
                    tool_responses.append({
                        "role": "tool",
                        "tool_call_id": tool_call.id,  # must match!
                        "name": fn_name,
                        "content": json.dumps(ret)
                    })
                    # Optionally: collect for outside use
                    if fn_name == 'find_topics':
                        topics_used = ret
                    elif fn_name == 'query_fuseki':
                        collected_problems.extend(ret)
                # Append the tool response(s) to the history
                messages.append({"role": "assistant", "content": None, "tool_calls": msg.tool_calls})
                messages.extend(tool_responses)
                # Now continue to next loop iteration (awaiting new assistant reply)
                continue

            # If not tool_calls: assistant is giving a normal answer/output
            try:
                worksheet_json = json.loads(msg.content)
                finished = True
                break
            except Exception as e:
                print("Did not get valid worksheet JSON. Got:\n", msg.content)
                raise e


        # for _ in range(max_iterations):

        #     # print("\n===== FULL MESSAGE HISTORY =====")
        #     # pprint.pprint(messages)
        #     # print("===== END MSG =====\n")

        #     completion = openai.chat.completions.create(
        #         model=self.gpt_model,
        #         messages=messages,
        #         tools=self.function_specs,
        #         tool_choice="auto"
        #     )
        #     msg = completion.choices[0].message
        #     if msg.tool_calls:
        #         for tool_call in msg.tool_calls:
        #             fn_name = tool_call.function.name
        #             fn_args = json.loads(tool_call.function.arguments)
        #             ret = functions_map[fn_name](**fn_args)
        #             # Show LLM the tool result as an assistant message (tool response)
        #             messages.append({
        #                 "role": "tool",
        #                 "tool_call_id": tool_call.id,
        #                 "name": fn_name,
        #                 "content": json.dumps(ret)
        #             })
                    
        #             # Save used topics to avoid repeating
        #             if fn_name == 'find_topics':
        #                 topics_used = ret
        #             elif fn_name == 'query_fuseki':
        #                 collected_problems.extend(ret)
        #         continue
        #     # If not calling tools, it's a user-facing answer (worksheet)
        #     try:
        #         worksheet_json = json.loads(msg.content)
        #         finished = True
        #         break
        #     except Exception as e:
        #         print("Did not get valid worksheet JSON. Got:\n", msg.content)
        #         raise e
            



        if not finished:
            print("[FAIL] LLM did not finish in allowed iterations.")
        else:
            self.write_json(worksheet, worksheet_json)
            print("[OK] Worksheet written to worksheet.json")

        return (0, merged_task)
